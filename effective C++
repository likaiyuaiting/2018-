<h1 align="center" style="color:red">effective C++</h1>
------
------
1. C++  由 C语言  面向对象  模板编程  STL组成
2. 尽量用 const  enum  inline  替换 #define  
3. 多使用const
4. 对象被使用前保证初始化
5. 类中默认存在的函数  构造函数  拷贝构造函数 析构函数  =操作符函数  这些都是 public且inline的  执行浅拷贝
6. 不要使用编译器默认生成的函数，应该显示自己实现，明确拒绝，如果不希望有拷贝构造或者是=操作，则显示定义这两个函数为private  可以只声明，不实现
7. 为多态基类声明virtual析构函数，来保证资源被释放完全，如果类不会被继承，不要将析构函数声明为virtual的，不要尝试去继承标准容器 string 或者 vector 等，因为他们的析构函数都不实virtual的，为抽象类提供一个纯虚析构函数，并且必须为此析构函数提供定义
8. 析构函数不要抛出异常，如果一个被析构函数调用的函数可能会抛出异常，析构函数应该捕捉异常，结束程序或者处理掉，如果需要对某个函数运行期间抛出的异常做出反应，class应该提供一个普通的成员函数，而不是由析构函数执行操作。
9. 绝不在构造和析构函数过程中调用virtual函数，vptr指针在构造函数完成后完成初始化，在析构函数结束时释放，所以在构造和析构中调用虚函数没有意义，相反可能会带来一些问题。
10. 重载=操作符时返回一个（*this）的引用 来实现链式编程 a=b=c
11. 重载=操作符时，在内部处理自我赋值，看起来有点傻，但可能出现 a[i] = a[j] i=j时，所以 如果 自我赋值时，返回（*this）的引用  注意在重载时，使用这样：不要直接删掉原来的空间，而是 mystring *ptemp = p_data;p_data=new mystring();delete ptemp; return *this;这样当new失败时还可以保持原来不变。
12. 拷贝对象时应该拷贝其所有成员
13. 使用智能指针管理资源，防止内存泄露
14. 成对使用new delete时使用相同形式new delete  new[]  delete []
15. 使用const test &obj 代替 test obj这样可以避免调用拷贝构造函数又不会改变对象的值，不适用于内置类型，int等和STL的迭代器和函数对象
16. 必须返回对象时，不要返回对象的引用，如果对象是在栈上创建，在函数结束时已经析构返回引用是致命的，返回对象通过拷贝构造函数或=操作符来赋值
17. 将成员变量声明为private
18. 啥时候使用变量再定义
19. 尽量少使用类型转换，使用C++的类型转换 const_cast 将const变量转为非const    dynamic_cast 用在多态时动态转化父类子类指针失败返回NULL   reinterpret_cast  类似于强制类型转换  static_cast  类似于隐式类型转换
20. 避免返回指针或引用指向对象内部
21. inline 内联函数只是对编译器的一个建议，不是强制的可以隐式建议在类内实现函数，friend被定义在类内也是隐式 ，明确申明的方法是函数申明前加inline，virtual 函数 inline无效 对构造函数 析构函数inline 无用因为构造函数析构函数可能会由编译器生成某些动作
22. 绝不重新定义继承来的非virtual函数例：B继承自A  A有func方法  B重定义了Func方法   有B test  A *pA； B *PB；  pA = &test； pB = &test； pA->func();  和 pB->func()； 结果是不同的，pA调的是A的func  pB调的是B的func   只是因为没有virtual  属于静态绑定  在编译期间就确定了。
23. 绝不重新定义继承而来的virtual缺省参数，例：B继承自A  都有virtual func  A的func（int a = 0） B的func（int  a） 这样的话以指针调用B的func不给参数可以，但以对象调用必须给参数，因为多态实现的基础就是指针或者引用 实现动态绑定，而对象静态绑定没有默认参数
24. 小心多重继承 菱形继承
25. 指针与引用的区别：
	1. 引用必须被初始化，而指针可以不初始化，存在空的指针，不存在空的引用，指针使用前应该检查合法性，引用则不必
	2. 指针可以重新改变指向，而引用一经初始化不可以改变引用对象
	3. 在考虑到存在不指向任何对象的可能或是在不同的时刻指向不同的对象时使用指针，如果总是指向一个对象并且不会改变指向使用引用，或者是重载某个操作符时使用引用
	4. 引用在汇编层面通过常指针实现，但使用常指针可能存在野指针的情况，所以引用更安全一些
26. 不要对数组使用多态，不要用一个数组存父类对象和子类对象
27. 没有无参构造函数在堆上定义数组时无法调用构造函数，无法再堆上创建，可以转化为创建对象指针数组，通过指针去分配内存调用有参构造函数
28. 重载后缀++时需要一个int参数占位不起作用，只是区分前缀++ 后缀++ 编译器会传一个0给这个参数   
	1. 前缀形式：先增加，后取值，重载时返回的是引用，增加后的值
	2. 后缀形式：先取值，后增加，重载时返回 const对象是被取回的值，如果不反回const对象  i++++这样的操作就是合法的了，后缀++需要建立一个临时对象，如果为了提高效率，应尽可能使用前缀++
29. C++中. .* :: ?: new delete sizeof  typeid  四个类型转换符 不能被重载，operator new  operator new []  operator delete  operator delete []  等允许被重载，但不要去重载 &&  ||  和 逗号，运算符 没有好的理由去重载他们
30. new 操作符 与operator new函数的区别： string *S = new string（"sdfa"）；这使用的是new操作符，这个操作符时内置的不能改变他的含义，他要完成的功能有两部分
	1. 分配内存
	2. 调用构造函数初始化内存中的对象。
	new操作符总是做这两件事情，不能以任何方式改变他的行为，我们所能做的是改变分配内存的方式，new操作符调用一个函数来完成内存分配，我们可以重写或重载这个函数来改变分配内存的行为 new操作符调用的函数是operator  new  函数operator new通常这样声明 void operator new（size_t size）返回一个未初始化的void指针，size参数用来分配内存大小，可以增加参数来重载这个函数，但第一个参数必须是size_t，一般不会直接调用operator new函数但是可以这样做，如果你想的话：void *memeory = operator new（10）；
	你调用new操作符，编译器帮你调用operator new函数和构造函数来完成对象的创建。
31. placement new：一个特殊的operator new 可以在一些已有的但尚未被处理内存上调用构造函数创建对象，例如共享内存上 
例：
test *constructObj(void *buffer,int size) 
{
	return new(buffer) test(size);
}
这个函数返回一个指针指向一个test对象，对象的内存在buffer里分配，这就可以解决在共享内存上创建对象的问题。 
  placement new 原型： void *operator new （size_t，void *location）{return location；}其中size_t参数不起作用了  必须包含#include <new>头文件
	1. 如果想在堆上建立一个对象，使用new操作符。即分配内存，又调用构造函数
	2. 如果只是想分配内存，调用operator new 函数，不会调用构造函数。
	3. 如果想定制内存分配过程重载operator new函数然后调用new操作符
	4. 如果想在一块已获得的内存里（如共享内存） 建立对象，使用placement new
	5. delete与new 是一样的，如果用placement new建立的对象，避免使用delete 操作符，因为delete会调用operator delete函数释放内存，但内存不是由operator new分配的，会出现错误，如果内存是共享内存，应该在类的析构函数中释放内存，应该显示的调用析构函数来释放内存。
31. new 一个数组 string *s = new string[10]; new依然是new操作符但不是调用operator new函数分配的内存，而是operator new[]分配，他与operator new一样可被重载，允许自己控制数组内存分配
new和delete操作符是内置的不可以被重载 重载的是new delete调用的函数
32. 当通过传递一个对象或一个常引用当参数时会产生临时对象（匿名对象） 传递对象会调用拷贝构造函数生成一个副本，而常引用则会类型转换生成副本，非常量引用则不会这就是为什么传引用可以改变值，因为修改的就是引用本身所引用的对象，而常引用和传值修改的是匿名对象 和本身无关，第二种产生匿名对象的场景是通过返回值返回一个对象，会产生匿名对象，为了解决这个匿名对象带来的开销 错误的方法是试图去返回一个常引用如果这个引用的对象在栈上 这就返回了一个不存在的值，如果返回一个在堆上分配的指针，通常又会导致内存泄露，某些函数必须返回对象，不必为其返回对象的开销而担心。
33. 在自定义的类里想使用X+=y这样的操作需要重载+= 不仅仅重载+和=
34. 虚函数 虚函数表（vbtl）虚函数表指针 vptr  
虚函数表 是一个函数指针数组（有的编译器也可能实现为链表）里面存放类的虚函数地址用来实现多态，每个虚函数表中的函数地址是自己的虚函数和父类没有被重写的虚函数以及自己重写的父类虚函数
虚函数表指针 指向虚函数表，每个申明了virtual函数的类都有他是一个隐藏的成员变量
实现多态时通过vptr指针找到虚函数表自己的vbtl，找到对应调用函数在vbtl中的位置，偏移到这个位置，调用这个位置中的函数指针对应的函数
例如：void func（test *p）
	 {
		p->f1();
	 }
 f1在vbtl中的索引为i
就相当于（*（p->vptr[i]））（p） 通过p找到vptr 通过vptr与偏移量或索引找到函数指针 然后将p当做参数传入调用函数
虚函数不能是内联的，内联在编译期间确定，而虚函数直到运行期间才确定。当通过对象调用虚函数时可以被内联，但大多数虚函数是通过对象的指针或者是引用来调用的不可以被内联，因为这是标准调用，所以说虚函数不能被内联
35. 通过非成员函数调用虚成员函数实现非成员函数多态 
36. 要想限制类生成的对象数量在static上下手，例如只生成一个对象，可以将构造函数等private，定义一个static 成员函数里面建立一个static静态对象，这样只能调用这个函数创建对象，而这个对象只会被创建一次，或者是在友元函数中定义静态对象，这种方法比在类中创建静态对象要好，因为类中的静态对象无法保证初始化时间，要想创建固定个数的对象，定义一个静态成员计数器，在构造函数里加1，析构函数里-1，当超过某个数值时，构造函数抛出异常
37. 禁止一个对象在栈上建立，或者是只能建立在堆上，就是不能让编译器去调用他的构造或析构，可以将它的析构函数设为private的，然后在成员函数中增加一个伪析构函数调用真正的析构函数释放内存，当然这样做就使得类不能被继承    判断对象是否在堆中，可以在一个函数中定义一个局部变量，这个局部变量必然在栈顶，与对象的地址比较，因为堆向上生长，栈向下增长，所以只要局部变量地址大于对象地址，这个对象就有可能是堆上的，但是因为有static对象的存在，你无法判断对象是在堆上还是静态区，正确的解决方法是 重载operator new 手动分配内存，将分配的内存挂在一个链表上，当delete时删除链表结点，这样只需要判断对象的地址在不在链表结点上就可以判断对象是否在堆上创建的    禁止一个对象在栈上创立，可以重载operator new 函数并且将它设为 private 这样new操作符无法调用 operator new函数 就不可能在堆上创建对象。
38. 引用计数： 允许多个有相同值的对象共享这个值的实现，第一个用途是 一块内存可以被多个对象所拥有，每增加一个对象就引用计数+1，每减少一个就-1 当减为0是释放内存   第二个作用是，如果很多对象拥有相同的值 每个都存储一遍是无用的，只需要让所有对象共享这个值，可以节省内存，提高效率，实现引用计数，当创建一个对象时判断他和已有对象值是否相同，相同时只需让他指向已有内存，通过引用计数引出来copy-on-write 写时复制 提高效率
39. extern "C"
	{
		声明函数//表示这些函数使用C的方式编译，不对函数名进行变换
	}
40. 将new delete  malloc  free 不要混用，对于基本类型来说可能混用也没什么，但混用他们是一个未定义行为
41. 全局对象和静态对象的初始化在main函数之前执行，意味着他们的构造函数在main之前执行，析构在main之后析构
42. 想在同一程序中使用C/C++的混合编程，要将在两种语言下都使用的函数声明为extern "C" ,不要混用动态内存分配的函数与操作符



--------
--------
<h1  align="center" style="color:red">深度探索C++对象模型 </h1>
-------
-------

1.	每个对象都含有类的非静态数据成员，内联函数每个对象都会产生一个函数实体，非内联函数只会产生一个函数实体，所有对象共享这个函数实体
2.	在C++中有两种类数据成员 static 和 普通数据成员，有三种成员函数 static  普通  virtual函数
3.	有两种模型： 1.将所有成员放在放在表单中，对象包含指向这些表单的指针。2.将成员函数放在成员函数表中，数据成员放在数据表中，对象包含两个指向表的指针，不过C++对象模型并没有采用这两种模型
4.	C++对象模型： 非静态数据成员被配置于每一个对象之中，static成员数据  static  和 非static 成员函数被放在类之外，virtual 函数 则是  有一下两个步骤支持：
	1. 每一个类产生一堆指向虚函数的指针，放在表格中，称之为vtbl 虚函数表。
	2. 每一个对象被添加了一个指针指向相关的vtbl称之为vptr vptr 的设置与重置都由类的构造函数析构函数 赋值运算符=自动完成，
5. struct 和 class 只有默认public  还是 private 的区别，完全可以把struct 当做class使用  当然这是在C++中
6. C中把一个拥有单一元素的数组放在struct的末尾，分配空间后可以使这个struct拥有可变大小的数组，这是柔性数组  在C++中复杂的继承，虚继承可能会导致问题
7. C++中凡是位于同一访问控制级别的数据在内存中按其声明顺序依次存放但不同访问级别的数据就不一定了，基类和派生类的数据存放位置也没有先后的强制规定
8. 一个C++对象的大小是其所有非静态的数据成员大小（内存对齐后）+ vptr（如果有）的大小
9. 初始化列表使用情况：
	1. 初始化一个引用数据成员
	2. 初始化一个const 数据成员
	3. 调用一个基类的构造函数，并且该基类没有默认构造函数，显式调用其有参构造函数
	4. 数据成员中有其他类的对象，并且该对象没有无参构造函数，显示调用该对象的构造函数为其初始化，类似A(2) A是对象 2是参数  
	初始化列表中初始化的顺序使数据成员在类中出现的顺序，不是初始化列表的顺序，合理的使用初始化列表，构造函数会先执行初始化列表的内容
10. C++中的相同访问控制级别的普通数据成员在内存中按顺序存放，vptr指针根据编译器的不同 放置位置不同，有的在开头，有的在成员数据最后，由编译器将其放置在任意位置。对于多继承引入虚拟继承解决二义性问题，引入了虚基类表
11. 成员函数通过this指针对成员数据操作，成员函数的第一个位置会由编译器加上一个参数this指针，静态成员函数将会被编译器转换为普通的函数调用，不传递this指针，因为没有this指针所以无法访问对象的数据只可以访问静态成员数据
12. 每个类只有一个虚函数表，所有对象共享这个虚函数表，只是多态时传入自己的this指针而已，这个表中存放函数指针，自己的虚函数，继承自基类的虚函数，重写的父类虚函数，为了找到这些函数地址，每一个函数指针都有一个索引,多继承时几个父类有虚函数就会生成几个vptr指针，对应生成几个vbtl表。
13. 继承会先调用父类构造函数然后调用子类构造函数
14. vptr指针初始化完成是在构造函数完成后，反正就是在构造函数中调用虚函数不能实现多态，确保安全，不要再构造析构中调用虚函数
